<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC</title>
  </head>

  <style>
    #vid-container {
      display: flex;
    }
  </style>
  <body>
    <h1>WebRTC Test</h1>

    <div id="vid-container">
      <video autoplay playsinline muted id="localVid"></video>
      <video autoplay playsinline muted id="remoteVid"></video>
    </div>

    <button id="startCall">Start Call</button>
    <button id="endCall" disabled>End Call</button>

    <script>
      const localVideo = document.getElementById("localVid");
      const remoteVideo = document.getElementById("remoteVid");

      const startBtn = document.getElementById("startCall");
      const endBtn = document.getElementById("endCall");

      const signalling = new BroadcastChannel("webrtc");

      let localStream;
      let pc;

      signalling.onmessage = (e) => {
        if (!localStream) {
          console.log("Not ready yet.");
          return;
        }

        switch (e.data.type) {
          case "offer":
            handleOffer(e.data);
            break;
          case "answer":
            handleAnswer(e.data);
            break;
          case "candidate":
            handleCandidate(e.data);
            break;
          case "ready":
            if (pc) {
              console.log("already in call ingnoring");
              return;
            }
            makeCall();
            break;
          default:
            console.log("Unhandled");
            break;
        }
      };

      const constraints = {
        video: true,
        audio: true,
      };

      async function makePeerConnection() {
        pc = new RTCPeerConnection();
        pc.onicecandidate = (e) => {
          const message = {
            type: "candidate",
            candidate: null,
          };

          if (e.candidate) {
            message.candidate = e.candidate.candidate;
            message.sdpMid = e.candidate.sdpMid;
            message.sdpMLineIndex = e.candidate.sdpMLineIndex;
          }

          signalling.postMessage(message);
        };

        pc.ontrack = (e) => (remoteVideo.srcObject = e.streams[0]);
        localStream
          .getTracks()
          .forEach((track) => pc.addTrack(track, localStream));
      }

      async function makeCall() {
        await makePeerConnection();

        const offer = await pc.createOffer();
        signalling.postMessage({ type: "offer", sdp: offer.sdp });
        await pc.setLocalDescription(offer);
      }

      async function handleOffer(offer) {
        if (pc) {
          console.error("existing peer connection");
          return;
        }

        await makePeerConnection();
        await pc.setRemoteDescription(offer);

        const answer = await pc.createAnswer();
        signalling.postMessage({ type: "answer", sdp: answer.sdp });
        await pc.setLocalDescription(answer);
      }

      async function handleAnswer(answer) {
        if (pc) {
          console.error("existing peer connection");
          return;
        }

        await pc.setRemoteDescription(answer);
      }

      async function handleCandidate(candidate) {
        if (pc) {
          console.error("existing peer connection");
          return;
        }

        if (!candidate.candidate) {
          await pc.addIceCandidate(null);
        } else {
          await pc.addIceCandidate(candidate);
        }
      }

      startBtn.onclick = async () => {
        try {
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
          localVideo.srcObject = localStream;

          signalling.postMessage({ type: "ready" });
        } catch (e) {
          console.log("An error occured : ", e);
        }
      };
    </script>
  </body>
</html>
